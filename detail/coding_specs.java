/**
 * 发现和提出问题，设计问题的解决方案，对解决方案的实践。
 */


/**
 * 产品与设计篇
 */
1. 少于80%用户需要使用的功能不要开发。

2. 新开发的功能应该极简单。
   这样做有2个好处: 方便更深入地理解该功能的意义，方便后续扩展或重做。


/**
 * 编码篇
 */
0. 永远不会被执行，开发过程中遗留的旧版本代码必须完全删除。
   现存代码每行都是有用代码。

1. 不能有循环依赖，类图不能有环。

2. 函数不超过150行。

3. 函数形参名不能缩写，局部变量可以缩写。

4. [begin, end) 左闭右开。[from, to) 左闭右开。
   interval/span 表示时间上的区间。region 表示地域或空间上的区间。

5. if-else ?: 先列出异常条件，再是正常逻辑。

6. 模块(小到类)的每个对外开放接口或函数必须要有完整的测试用例(包括异常测试和功能测试)。
   测试用例是文档的一部分。

7. 不要在代码里省略数据类型的编写，如写java的Lambda表达式时不要把"(Integer i) -> i>0"写成"(i) -> i>0"，
   除非在同一条语句中可以立即看到数据类型，如"List<Integer> b = a.stream().filter(i -> i>0);"。
   好的思维是看到函数应先知道它操作的值类型是什么输出的又是什么，所以带上数据类型可以方便别人阅读代码。

8. 同一个文件下定义的函数的组织顺序: 对外public的接口靠前，被调用的紧跟调用者。
   例如: [ A a1 a2 B b ]，函数A依赖a1和a2，函数B依赖b，函数A和B是公开接口。

9. 尽量在函数或方法的输入参数表中使用const final关键字。

10. 具体子类的任何方法不要依赖抽象类中依赖由子类实现的抽象方法的方法，因为这种依赖关系使得阅读者
   需要在抽象类和具体子类的代码间来回切换。更一般的是不要在依赖图中形成环。

11. 不要直接对枚举类型序列化，应该转成整型，并且在反序列化时检查。

12. 循环的前面部分的组织方式: 先写输入准备，再写输出结果的构造。


/**
 * 实践篇
 */
1. 如何准确地估计出某个功能实现的实际工作量。
   第1步，统计该功能依赖的模块数和功能实现后依赖它的模块数，
          由这2个量确定实现功能的准备工作量和功能完成后的测试工作量；
   第2步，客观求实地确定需要重构的代码量，包括删除/重构/重写旧代码数量，
          由此确定代码整理工作量；
   第3步，估计代码量和代码逻辑复杂度，由这2个量确定代码工作量；
   第4步，根据实际情况确定各个量的权重，求和得出实际工作量；

2. 数据(输入输出值/状态量)，数据结构，算法，模块。
   组合聚合结构(整体和部分之间的关系)。
   带时序性的依赖关系(部分和部分之间的联系)。

3. 阅读源码，找一个点入手，了解这个的功能和概念，可以通过测试或示例代码了解，猜测实现并看源码来了解具体实现。
   不一定要知道每个细节，但要知道你不知道，而且要确保你知道的东西的正确性。
   写一些小程序，使用或测试源码。
   正确阅读源码时速度是很快的，因为不是在写。

4. 打补丁和优化的区别是，前者是在错误的道路上向终极目标靠近，后者是在正确的道路上向目标靠近。
   如同走迷宫，出口处有一座大山让你在每个点都能看到(终极目标清晰)。
   错误的设计如同终点是一堵墙而非出口的道路，打补丁让你在视觉和心理上觉得离出口更近，实际上当你最终不得不返回时更远。
   好的leader和架构师可以在走了一小段路后判断出这是一个死胡同，
   而现实中糟糕的leader会强迫你在错误道路上一直走，直至摸到了墙他还不知道，因为是你而不是他摸到了墙。

5. 如果设计者一开始想着功能更灵活更强大，那么结局往往是使用时发现这些意淫出来的灵活和强大完全没有必要，
   而一些必要的功能却由于系统的复杂不能加入。Stay Foolish，告诉我们思想要单纯一点。

6. 库函数工具应该没有歧义性，即完成一件事只有一种使用库工具的方法，没有多种。这样开发者容易正确和高效地使用库工具。

7. 不要想着做太多的扩展，因为你的扩展以后未必会用到，以后要用的功能在你的扩展中未必有。
   想过多的将来不如把当下的性能做好。让当前的功能是高稳定高可用。
   灵活的架构是演进(重构)而来的，不是一开始设计好的。已有的好的设计模式只是在重构时才发挥作用。
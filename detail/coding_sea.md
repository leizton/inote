# 好代码的特点
1. 命名简单直接达意, 符号习惯
2. 函数和类的实现符合单一职责、高内聚, 逻辑简单直接, 易于微观把握
3. 类之间的依赖关系呈树形分层结构, 没有循环依赖, 条理清晰, 分门别类, 易于宏观把握

# 需求
- 低于10%用户使用的功能不要开发
- 新开发的功能应该极简单
  好处: 尽快上线以获得反馈从而迭代, 迭代是更深入地理解该功能的意义并发掘潜力, 降低后续扩展或重做或放弃的成本

# 编码
- 检查输入参数
- delete p后必须置NULL, p=NULL
- 位运算符必须加足够的括号
- 永远不会被执行, 开发过程中遗留的旧版本代码必须完全删除, 现存代码每行都是有用代码
- 不能有循环依赖, 类图不能有环
- 函数不超过150行
- 函数形参名不能缩写, 局部变量可以缩写
- [begin, end)左闭右开, [from, to)左闭右开
  interval/span表示时间上的区间, region表示地域或空间上的区间
- if-else和?:, 先列出异常条件, 再写正常逻辑
- 模块(小到类)的每个对外开放接口或函数必须要有完整的测试用例(包括异常测试和功能测试)
  测试用例是文档的一部分
- 不要在代码里省略数据类型的编写, 如写java的Lambda表达式时不要把"(Integer i) -> i>0"写成"(i) -> i>0", 
  除非在同一条语句中可以立即看到数据类型, 如"List<Integer> b = a.stream().filter(i -> i>0);"
  一般读代码时看到函数先理解它的功能和输入输出的含义, 所以带上数据类型方便别人阅读
- 同一个文件下定义的函数的组织顺序: 对外public的接口靠前, 被调用的紧跟调用者
  例如: [ A a1 a2 B b ], 函数A依赖a1和a2, 函数B依赖b, 函数A和B是公开接口
- 尽量在函数或方法的输入参数表中使用const final关键字
- 具体子类的任何方法不要依赖抽象类中依赖由子类实现的抽象方法的方法, 因为这种依赖关系使得阅读者
  需要在抽象类和具体子类的代码间来回切换更一般的是不要在依赖图中形成环
- 不要直接对枚举类型序列化, 应该转成整型, 并且在反序列化时检查
- 循环的前面部分的组织方式: 输出变量, 循环体变量, 循环头变量
- 不要只是打补丁, 还要从根本上解决
- 不要想着做太多的扩展, 因为你的扩展以后未必会用到, 以后要用的功能在扩展中未必有
  stay foolish
  想过多的将来不如把当下的性能做好让当前的功能是高稳定高可用
  灵活的架构是演进(重构)而来的, 不是一开始设计好的已有的好的设计模式只是在重构时才发挥作用

# 运维
- 不要在同一个ip或host上部署同一个服务的不同进程

# target制定
1. 需要查找和解决的issue/bug, 正在尝试以及可能有用的查找方案
2. 需要定位的性能瓶颈, 定位方案
3. 需要优化的性能瓶颈, 优化方案
4. 需要优化的性能问题
5. 需要提高用户体验的已有功能
6. 新增的功能

# 基础服务和中间件
- config_service, 支持热更新
- 定时调度任务
- kv_store, base on redis, capacity less 200GB
- DFS
- rpc & msg_queue
- monitor & log_service & trace

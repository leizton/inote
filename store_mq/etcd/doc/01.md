# 01 basic
- etcd是一个分布式kv存储系统,用于共享配置和服务发现,底层通过raft实现一致性
- 记录key的每个历史版本值
- 维护一个字段序的B树索引
- ./bin/etcd
    --name $node3  ;当前节点名称
    --listen-peer-urls http://127.0.0.1:2383  ;当前节点bind这个url,使其他节点可以和自己通信
    --initial-advertise-peer-urls http://127.0.0.1:2383  ;same with listen-peer-urls
    --listen-client-urls http://127.0.0.1:2393  ;当前节点bind这个url, 好让client访问自己
    --advertise-client-urls http://127.0.0.1:2393  ;same with listen-client-urls
    --initial-cluster-token myetcd1  ;所属集群的标识
    --initial-cluster $node1=http://127.0.0.1:2381,$node2=http://127.0.0.1:2382,$node3=http://127.0.0.1:2383  ;集群中所有节点的initial-advertise-peer-urls集合
    --initial-cluster-state new
- etcd启动方式: 静态配置发现, 服务发现, DNS发现


# 02 raft
- 在程序不会崩溃(代码bug,服务器掉电等),网络可靠且无延迟的理想情况下,容易保持集群中各节点间状态一致
- 一致性协议(如paxos,raft)保证集群中超过半数以上节点可用时,集群能给出正确的结果
- Paxos在理论上证明是正确的,但难以理解和实现,其实现都做了大的改动而未经证明
## raft leader选举
- 2个超时时间: heartbeat-timeout election-timeout
- 节点有3种状态(角色): leader, follower, candidate
- node初始状态是follower
  follower: 如果已有leader,当leader的心跳超时,则启动election计数器; 如果没有leader,则直接启动election-timer;
    当election-timer超时,变成candidate,以发起新一轮投票;
    收到投票请求时,若未透出票,则投票,否则拒绝, 投票后清零election-timer防止同一时间出现多个candidate;
  candidate: 先向自己投1票, 把任期term增1并标记投给自己; 再向其他node发出投票请求, 并清零election-timer;
    当收到超过半数的其他follower投票时变成leader, 并向follower发心跳防止follower的election-timer超时,
      因此heartbeat-timeout应小于election-timeout;
  leader: 接收client的请求; 和follower维持心跳, follower收到心跳会重置election-timer;
- 每个node记录当前任期号和自己的投票结果
- 选举时, 如果candidate数量大于1, 可能导致这一轮选举失败.
  因此每个candidate的election-timeout是在一个区间上的随机值, 使得同时有多个candidate概率变小, 是活锁
- raft要求: 广播时间 << election-timeout << 平均故障间隔时间.
  广播时间指集群中任意节点通信的往返时间(round trip time, RTT)
## 日志复制
- leader对于每个client的update请求都写日志记录, 并把record通过发消息同步给follower, 超过半数follower响应同步成功时认为该记录是committed;
  committed的record会被leader应用到自身的状态机中, 同时leader会通知follower应用该record; 最后响应client
- 每个node维护commitIdx和lastAppliedIdx. commitIdx是当前节点最大的日志索引值, lastAppliedIdx是最后一条被应用到状态机的record的日志索引值.
  leader维护了每个follower的matchIdx和nextIdx, matchIdx是follower响应leader同步成功的位置, nextIdx是leader下次向follower发日志的起始位置,
  由于采用批量发送, nextIdx和matchIdx间的差值 <= batchNum
- leader更替后, new_leader并不知道old_leader的matchIdx和nextIdx, 因此matchIdx都置0, nextIdx置成自己的commitIdx;
  当某些follower同步比new_leader慢, 则会响应追加日志失败, new_leader减少其nextIdx
- 选举时, follower会拒绝投票给commitIdx小于自己的candidate, 以保证不丢失record